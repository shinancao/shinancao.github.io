<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Objective-C,GCD,多线程,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=5.1.1">






<meta name="description" content="对于iOS的多线程编程，可以使用C语言开发的POSIX 线程 API，也即pthread，或者Objective-C中提供的对该API的封装NSThread。然而线程管理是一件非常复杂的事，管理不当还会影响程序性能，为了避免开发者可能造成的对线程的糟糕的使用，也为了能更好地利用设备上的多核CPU，苹果在OS X 10.6和iOS4中引入了Grand Central Dispatch (GCD)。对">
<meta name="keywords" content="Objective-C,GCD,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C and Swift GCD API  ">
<meta property="og:url" content="http://shinancao.github.io/2019/06/15/iOS-GCD-API/index.html">
<meta property="og:site_name" content="意林的小站">
<meta property="og:description" content="对于iOS的多线程编程，可以使用C语言开发的POSIX 线程 API，也即pthread，或者Objective-C中提供的对该API的封装NSThread。然而线程管理是一件非常复杂的事，管理不当还会影响程序性能，为了避免开发者可能造成的对线程的糟糕的使用，也为了能更好地利用设备上的多核CPU，苹果在OS X 10.6和iOS4中引入了Grand Central Dispatch (GCD)。对">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://shinancao.github.io/images/serial_queue.jpg">
<meta property="og:image" content="http://shinancao.github.io/images/concurrent_queue.jpg">
<meta property="og:image" content="http://shinancao.github.io/images/target_queue.jpg">
<meta property="og:image" content="http://shinancao.github.io/images/barrier_queue.jpg">
<meta property="og:updated_time" content="2019-08-11T23:52:52.315Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C and Swift GCD API  ">
<meta name="twitter:description" content="对于iOS的多线程编程，可以使用C语言开发的POSIX 线程 API，也即pthread，或者Objective-C中提供的对该API的封装NSThread。然而线程管理是一件非常复杂的事，管理不当还会影响程序性能，为了避免开发者可能造成的对线程的糟糕的使用，也为了能更好地利用设备上的多核CPU，苹果在OS X 10.6和iOS4中引入了Grand Central Dispatch (GCD)。对">
<meta name="twitter:image" content="http://shinancao.github.io/images/serial_queue.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shinancao.github.io/2019/06/15/iOS-GCD-API/">





  <title>Objective-C and Swift GCD API   | 意林的小站</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">意林的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Be a cool girl ~</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-portfolio">
          <a href="/portfolio/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br>
            
            项目
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://shinancao.github.io/2019/06/15/iOS-GCD-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="意林">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="意林的小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Objective-C and Swift GCD API  </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T06:40:32+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对于iOS的多线程编程，可以使用C语言开发的<a href="https://en.wikipedia.org/wiki/POSIX_Threads" target="_blank" rel="noopener">POSIX 线程</a> API，也即<code>pthread</code>，或者Objective-C中提供的对该API的封装<code>NSThread</code>。然而线程管理是一件非常复杂的事，管理不当还会影响程序性能，为了避免开发者可能造成的对线程的糟糕的使用，也为了能更好地利用设备上的多核CPU，苹果在OS X 10.6和iOS4中引入了Grand Central Dispatch (GCD)。对于GCD的描述，在苹果的官方文档中有如下描述：</p>
<p>GCD是异步执行任务的技术之一。它将开发者一般在程序中写的管理线程的代码移到了系统级中实现。你要做的事就是定义要执行的任务，然后把任务添加到合适的队列中。GCD负责创建线程执行任务。因为线程管理是系统级的一部分了，所以GCD可统一管理任务并执行，这样就比以前的线程更有效率。</p>
<p>GCD的执行效率更高，尽管是C语言的API，但是使用起来却很方便，本篇文章将会对我们开发中经常用到的API做一总结，内容比较长，可以在右侧目录找想看的。</p>
<p>其实Objective-C中也提供了对GCD API的封装，就是<code>NSOperationQueue</code>，它提供了一些GCD无法直接做到的特性。下一篇文章会详细的总结一下<code>NSOperationQueue</code>。</p>
<a id="more"></a>
<h2 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h2><p>Dispatch Queue是<strong>FIFO</strong>队列。队列中放的就是待执行的任务，这些任务用一个个Block语法块进行封装，所以实际放到队列中的是Block语法块。按照同时能执行任务的个数，GCD中有两种队列：串行队列Serial Dispatch Queue和并行队列Concurrent Dispatch Queue。串行队列一次执行只能执行一个任务，下一个任务必须等待当前的任务执行结束，才能开始执行。并行队列可以同时执行多个任务，下一个任务不用等待当前任务执行结束再开始执行，但是任务的开始顺序还是按照先进先出原则，先添加到队列中的任务先开始执行。也就是说GCD用了一个线程来处理串行队列中的任务，用了多个线程来处理并行队列中的任务。但是能并行处理多少个并行队列中的任务，是由当前系统的状态决定的。</p>
<p><img src="/images/serial_queue.jpg"></p>
<p><img src="/images/concurrent_queue.jpg"></p>
<h3 id="创建自定义队列"><a href="#创建自定义队列" class="headerlink" title="创建自定义队列"></a>创建自定义队列</h3><p>Objective-C中可以通过<code>dispatch_queue_create</code>创建一个Dispatch Queue。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> mySerialDispatchQueue = dispatch_queue_create(<span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>第一个参数给该Dispatch Queue指定一个唯一标识，这个标识最好采用反向域名的格式，这样在debug工具中我们可以很容易找到自定义的Dispatch Queue。第二个参数可以设置为<code>DISPATCH_QUEUE_SERIAL</code>或者NULL创建一个串行对类，或者设置为<code>DISPATCH_QUEUE_CONCURRENT</code>创建一个并行队列。</p>
<p>这里要说一下GCD的内存管理，在iOS6及之后的版本，已经将GCD对象加入到了ARC的内存管理中。在这之前，开发者还需要对自己创建的队列，调用<code>dispatch_release</code>进行释放。</p>
<p>在Swift中可以直接通过<code>DispatchQueue</code>的构造函数创建一个Dispatch Queue。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mySerialDispatchQueue: DispatchQueue = DispatchQueue(<span class="keyword">label</span><span class="bash">: <span class="string">"com.example.gcd.MySerialDispatchQueue"</span>)</span></span><br></pre></td></tr></table></figure>
<p>打开<a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/2300059-init" target="_blank" rel="noopener">官方文档</a>可以看到，DispatchQueue的构造函数实际上有5个，并且其他4个参数都指定了默认值，所以我们可以像上面那样只传label的值。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">convenience</span> <span class="selector-tag">init</span>(<span class="attribute">label</span>: String, <span class="attribute">qos</span>: DispatchQoS = .unspecified, <span class="attribute">attributes</span>: DispatchQueue.Attributes = [], <span class="attribute">autoreleaseFrequency</span>: DispatchQueue.AutoreleaseFrequency = .inherit, <span class="attribute">target</span>: DispatchQueue? = nil)</span><br></pre></td></tr></table></figure>
<ul>
<li>label: 指定Dispatch Queue的唯一标识，通<code>dispatch_queue_create</code>中的label。</li>
<li>qos: 指定队列的优先级，在下面会跟Objective-C中的全局队列的优先级一起总结。</li>
<li>attributes: 不指定该项，创建的就是串行队列。如果要创建并行队列，可以设置为<code>.concurrent</code>。</li>
<li>autoreleaseFrequency: 指定block中创建的临时对象的释放策略。设置为<code>.inherits</code>，则该队列跟它的目标队列一样的释放策略。设置为<code>.workItem</code>，则该队列会在执行block之前创建一个autorelease pool，在执行后释放pool中的对象。设置为<code>.never</code>，则该队列不负责创建autorelease pool，交由开发者自行处理。所以最好还是设置为<code>.workItem</code>。</li>
<li>target：设置目标队列，后面会详细说一下目标队列。</li>
</ul>
<h3 id="主队列和全局队列"><a href="#主队列和全局队列" class="headerlink" title="主队列和全局队列"></a>主队列和全局队列</h3><p>除了直接创建Dispatch Queue，系统还提供了两个标准队列：主队列Main Dispatch Queue和全局队列Global Dispatch Queue。主队列是在主线程中执行的Dispatch Queue，因为主线程只有一个，自然<strong>主队列就是串行队列</strong>。另一个<strong>全局队列是所有应用程序都能够使用的并行队列</strong>。全局队列有4个执行优先级，高优先级（High Priority）、默认优先级（Default Priority）、低优先级（Low Priority）、后台优先级（Background Priority）。用于管理全局队列的线程，将各自把其使用的全局队列的优先级作为自己执行任务时的优先级。将系统提供的Dispatch Queue总结如下表：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Dispatch Queue的种类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main Dispatch Queue</td>
<td>Serial Dispatch Queue</td>
<td>主线程执行</td>
</tr>
<tr>
<td>Global Dispatch Queue (High Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：高（最高优先）</td>
</tr>
<tr>
<td>Global Dispatch Queue (Default Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：默认</td>
</tr>
<tr>
<td>Global Dispatch Queue (Low Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：低</td>
</tr>
<tr>
<td>Global Dispatch Queue (Background Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：后台</td>
</tr>
</tbody>
</table>
<p>在Objective-C中可以通过<code>dispatch_get_main_queue</code>获取主队列。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dispatch_queue_main_t mainDispatchQueue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<p>Swift中更简单，只要通过<code>DispatchQueue.main</code>就得到了主队列。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainDispatchQueue: <span class="attr">DispatchQueue</span> = DispatchQueue.main</span><br></pre></td></tr></table></figure>
<p>再来看一下全局对列，Objective-C中通过<code>dispatch_get_global_queue</code>获取。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dispatch_queue_global_t globalDispatchQueue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定优先级，第二个参数是一个保留字段，始终传0即可。在代码中查看它的API定义时可以看到，优先级的取值如下，是宏定义的几个值，所以默认优先级时也可以直接写0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br></pre></td></tr></table></figure>
<p>别急，接着往下看，还可以看到这样一段注释：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">* It is recommended to use quality of service class values to identify the</span></span><br><span class="line"><span class="comment">* well-known global concurrent queues:</span></span><br><span class="line"><span class="comment">*  - QOS_CLASS_USER_INTERACTIVE</span></span><br><span class="line"><span class="comment">*  - QOS_CLASS_USER_INITIATED</span></span><br><span class="line"><span class="comment">*  - QOS_CLASS_DEFAULT</span></span><br><span class="line"><span class="comment">*  - QOS_CLASS_UTILITY</span></span><br><span class="line"><span class="comment">*  - QOS_CLASS_BACKGROUND</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The global concurrent queues may still be identified by their priority,</span></span><br><span class="line"><span class="comment">* which map to the following QOS classes:</span></span><br><span class="line"><span class="comment">*  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span></span><br><span class="line"><span class="comment">*  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span></span><br><span class="line"><span class="comment">*  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span></span><br><span class="line"><span class="comment">*  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span></span><br></pre></td></tr></table></figure>
<p>所以这些宏定义是为了让开发者在使用时只简单地考虑优先级的高低等即可，不需要考虑具体场景再决定用哪个。当然也可以直接使用QOS classes指定优先级。</p>
<ul>
<li><code>QOS_CLASS_USER_INTERACTIVE</code> 指定为该QOS class的队列负责执行与用户交互相关的任务，比如动画、事件处理、更新UI等，所以有最高优先级。该优先级的队列应该只限于做与用户交互相关的任务，所以在上面优先级的宏定义中并没有将其暴露出来。</li>
<li><code>QOS_CLASS_USER_INITIATED</code> 指定为该QOS class的队列用来执行那些会阻碍用户使用你的App的任务，所以优先级也很高。</li>
<li><code>QOS_CLASS_DEFAULT</code> 默认优先级。</li>
<li><code>QOS_CLASS_UTILITY</code> 指定为该QOS class的队列用于执行那些用户不需要立即得到结果的任务，所以优先级相对较低。</li>
<li><code>QOS_CLASS_BACKGROUND</code> 指定为该QOS class的队列用于执行维护或清理等任务，用户不需要关心其结果。</li>
</ul>
<p>在Swift中队列的优先级取值就直接对应的上面这些，不再是简单的高或者低了。在创建队列时就可以指定优先级，即qos参数。同样地获取全局队列时也可以指定qos以获取对应优先级的队列，默认为<code>.default</code>。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认优先级队列</span></span><br><span class="line"><span class="keyword">let</span> globalDispatchQueue: DispatchQueue = DispatchQueue.<span class="keyword">global</span>()</span><br><span class="line"><span class="comment">// 获取高优先级队列</span></span><br><span class="line"><span class="keyword">let</span> globalDispatchQueueHigh: DispatchQueue = DispatchQueue.<span class="keyword">global</span>(qos: .userInitiated)</span><br></pre></td></tr></table></figure>
<p>qos的取值可为<code>.userInteractive</code>、<code>userInitiated</code>、<code>.default</code>、<code>.utility</code>、<code>.background</code>、<code>.unspecified</code>。</p>
<h3 id="目标队列"><a href="#目标队列" class="headerlink" title="目标队列"></a>目标队列</h3><p>其实在自定义队列中被调度的所有的block最终都将被放入到系统的全局队列和线程池中。默认情况下会把开发者创建的队列放入到默认优先级的全局队列中。但是也可以给自定义的队列设置一个目标队列，让其执行优先级与该目标队列的执行优先级一致。</p>
<p>不仅能改变优先级，如果一个队列是并行的，但是其目标队列是串行的，那么实际上这个队列也会转换为串行队列。再者，不同串行队列中的任务是可以同时执行的，如果把这些串行队列的目标队列都设置为同一个串行队列，那这些串行队列中的任务将不会并行执行。ObjC中国<a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">这篇文章</a>中的图，我稍稍调整了一下感觉会更合适。经过测试，如果自定义的串行队列的目标队列是并行队列，还是能保证该串行队列中的block是被串行调度的，所以目标队列设置为串行队列时才显得更有意义。</p>
<p><img src="/images/target_queue.jpg"></p>
<p>在Objective-C中通过<code>dispatch_set_target_queue</code>给一个队列设置其目标队列。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(<span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, NULL)<span class="comment">;</span></span><br><span class="line">dispatch_queue_global_t globalDispatchQueueLow = dispatch_get_global_queue(<span class="name">DISPATCH_QUEUE_PRIORITY_LOW</span>, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">dispatch_set_target_queue(<span class="name">mySerialDispatchQueue</span>, globalDispatchQueueLow)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>尽快自定义的队列中的任务最终都会放到全局队列中，但是为一个类创建它自己的队列而不是使用全局队列仍普遍被认为是一种好的风格。因为你可以给自定义的队列设置一个唯一的label，这在debug时非常有帮助。</p>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>Dispatch Queue中任务的执行，通常分异步和同步，异步和同步说的是当前的线程是否要等待队列中的任务执行结束，再接着执行后面的语句。如果是异步，当前的线程不用等待任务执行的结果，继续处理后面的语句。如果是同步，当前的线程要等待任务执行结束，才能再接着执行后面的语句。</p>
<h3 id="添加任务到队列"><a href="#添加任务到队列" class="headerlink" title="添加任务到队列"></a>添加任务到队列</h3><p>在Objective-C中可以通过<code>dispatch_async</code>函数异步将block追加到队列中，异步说的是<code>dispatch_async</code>不会阻塞调用它的线程，调用它的线程不会等它执行结束才能执行后面的语句。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue = dispatch_queue_create(<span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(mySerialDispatchQueue, ^&#123;</span><br><span class="line">	<span class="comment">// 在队列中要执行的语句</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Swift中对应的是DispatchQueue的实例方法<code>async</code>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let mySerialDispatchQueue: DispatchQueue = DispatchQueue(<span class="selector-tag">label</span>: <span class="string">"com.example.gcd.MySerialDispatchQueue"</span>)</span><br><span class="line"></span><br><span class="line">mySerialDispatchQueue<span class="selector-class">.async</span> &#123;</span><br><span class="line">	<span class="comment">// 在队列中要执行的语句</span></span><br><span class="line">	</span><br><span class="line">	DispatchQueue<span class="selector-class">.main</span><span class="selector-class">.async</span> &#123;</span><br><span class="line">       <span class="comment">// 执行的结果可能要放到主队列中处理         </span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，也可以同步将block追加到队列中，在Objective-C中使用<code>dispatch_sync</code>实现。调用了<code>dispatch_sync</code>的线程，必须要等它追加的任务执行结束后，才能执行后面的语句。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch_sync</span>(mySerialDispatchQueue, ^&#123;</span><br><span class="line">	<span class="comment">// 在队列中要执行的语句</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Swift中对应的是DispatchQueue的实例方法<code>sync</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mySerialDispatchQueue.<span class="keyword">sync</span> &#123;</span><br><span class="line">	<span class="comment">// 在队列中要执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用同步的方式追加任务时，要时刻小心是否造成<strong>死锁</strong>。比如下面这样就会产生死锁，导致程序崩溃。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_main_t mainDispatchQueue = dispatch_get_main_queue()<span class="comment">;</span></span><br><span class="line">dispatch_sync(<span class="name">mainDispatchQueue</span>, ^&#123;</span><br><span class="line">	NSLog(@<span class="string">"add task into main dispatch queue"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><code>dispatch_sync</code>在主线程中执行，主线程被阻塞等待<code>dispatch_sync</code>执行结束，这又导致block无法追加到主队列中，所以<code>dispatch_sync</code>又无法执行结束。</p>
<p>所以在日常开发中最好不要轻易使用同步等待处理的API，有时死锁的发生是很隐晦的，并不容易注意到，在想到用同步API的时候，再多想想还有没有其他的解决办法。</p>
<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>GCD还提供了API，可以在指定时间后将block追加到队列中，注意并不是执行，所以会有少许延迟。在Objective-C中该API是<code>dispatch_after</code>。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time_t </span>time = <span class="keyword">dispatch_time(DISPATCH_TIME_NOW, </span>(int64_t)(<span class="number">3</span> * NSEC_PER_SEC));</span><br><span class="line"><span class="keyword">dispatch_after(time, </span><span class="keyword">dispatch_get_main_queue(), </span>^&#123;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定从何时开始计算时间，类型是<code>dispatch_time_t</code>，可以通过<code>dispatch_time</code>函数获得相对时间，也可以通过<code>dispatch_walltime</code>函数获得绝对时间。</p>
<p>在Swift中使用DispatchQueue的实例方法<code>asyncAfter</code>来延迟追加任务。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">DispatchQueue</span><span class="selector-class">.main</span><span class="selector-class">.asyncAfter</span>(<span class="attribute">deadline</span>: DispatchTime.now() + <span class="number">2.0</span>) &#123;</span><br><span class="line">	<span class="comment">// 2秒后执行        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只执行一次"><a href="#只执行一次" class="headerlink" title="只执行一次"></a>只执行一次</h3><p><code>dispatch_once</code>函数保证在应用程序执行中只执行一次指定的block。我们一般会用它来实现单例模式，以确保单例的线程安全，而且它的性能要比<code>@synchronized</code>要好。<code>@synchronized</code>每一次都要先获取锁，而<code>dispatch_once</code>使用一个token标识代码是否执行过。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是在Swift 3.0中这个函数被废弃了，但是可以使用懒加载的全局变量或静态变量，也能保证线程安全。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onceTask: <span class="built_in">String</span> = &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"onceTask"</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h3 id="阻碍执行"><a href="#阻碍执行" class="headerlink" title="阻碍执行"></a>阻碍执行</h3><p><code>dispatch_barrier_async</code>函数会等待在它前面已追加到队列中的任务全部执行完，然后执行由<code>dispatch_barrier_async</code>函数追加的任务，该任务处理结束后，再继续执行<code>dispatch_barrier_async</code>函数后面追加的任务。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myConcurrentDispatchQueue = dispatch_queue_create(<span class="string">"com.example.gcd.MyConcurrentDispatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">	NSLog(@<span class="string">"Task 0"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">	NSLog(@<span class="string">"Task 1"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">	NSLog(@<span class="string">"Task 2"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_barrier_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">   NSLog(@<span class="string">"barrier"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">   NSLog(@<span class="string">"Task 4"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">   NSLog(@<span class="string">"Task 5"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/barrier_queue.jpg"></p>
<p>由此也可以看到，对串行队列执行<code>dispatch_barrier_async</code>是没有多大意义的。</p>
<p><code>dispatch_barrier_async</code>非常适合用来处理对单一资源的<strong>多读单写</strong>。对于读来说，多个线程同时读没有问题，只要保证写的时候只有一个线程在操作即可。所以使用并行队列效率会更高一些，然后在写的时候用<code>dispatch_barrier_async</code>控制同时只有一个线程操作。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_get_global_queue(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">- (<span class="name">NSString</span> *)someString &#123;</span><br><span class="line">    __block NSString *localSomeString<span class="comment">;</span></span><br><span class="line">    dispatch_sync(<span class="name">_syncQueue</span>, ^&#123;</span><br><span class="line">        localSomeString = _someString<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return localSomeString<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="name">void</span>)setSomeString:(<span class="name">NSString</span> *)someString &#123;</span><br><span class="line">    dispatch_barrier_async(_syncQueue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Swift 3.0中，调用<code>async</code>函数时，可以指定<code>flags</code>为<code>.barrier</code>。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myConcurrentDispatchQueue = DispatchQueue(labe<span class="variable">l:</span> <span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, attribute<span class="variable">s:</span> .concurrent)</span><br><span class="line"></span><br><span class="line">myConcurrentDispatchQueue.async(flag<span class="variable">s:</span> .barrier) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代执行"><a href="#迭代执行" class="headerlink" title="迭代执行"></a>迭代执行</h3><p><code>dispatch_apply</code>函数按指定的次数将指定的block追加到指定的队列中，并等待全部的block执行完毕。block带有一个参数用来告知当前迭代的index。<code>dispatch_apply</code>是同步的。</p>
<p>用<code>dispatch_apply</code>替代对数组等的for循环，把这些block放到并行队列中可以提高执行效率。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">   dispatch_apply([array count], myConcurrentDispatchQueue, ^(<span class="name">size_t</span> index) &#123;</span><br><span class="line">       NSLog(@<span class="string">"%zu: %@"</span>, index, [array objectAtIndex<span class="symbol">:index</span>])<span class="comment">;</span></span><br><span class="line">   &#125;)<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">   dispatch_async(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">       NSLog(@<span class="string">"done."</span>)<span class="comment">;</span></span><br><span class="line">   &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>同样地对串行队列执行<code>dispatch_apply</code>的意义不大，所以在Swift 3.0中直接就实现为并行地执行block了。使用DispatchQueue的类方法<code>concurrentPerform</code>。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.concurrentPerform(iteration<span class="variable">s:</span> <span class="number">10</span>) &#123; (<span class="built_in">index</span>) in</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="挂起-恢复队列"><a href="#挂起-恢复队列" class="headerlink" title="挂起/恢复队列"></a>挂起/恢复队列</h3><p><code>dispatch_suspend</code>函数挂起指定的队列，<code>dispatch_resume</code>函数恢复指定的队列。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(<span class="name">queue</span>)<span class="comment">;</span></span><br><span class="line">dispatch_resume(<span class="name">queue</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这两个函数不会影响已经在执行的任务，挂起后，追加到队列中的但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</p>
<p>在Swift中用起来类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.suspend()</span><br><span class="line"><span class="built_in">queue</span>.resume()</span><br></pre></td></tr></table></figure>
<h2 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h2><p>如果你想在一组并行执行的任务都完成之后再去处理其他事情，就可以使用Dispatch Group来处理。GCD提供了两种方式来实现，可以视具体情况而定用哪一种。一种是直接追加block到group中。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建group</span></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, myConcurrentDispatchQueue, ^&#123;</span><br><span class="line">	NSLog(@<span class="string">"blk0"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 相继追加block</span></span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, myConcurrentDispatchQueue, ^&#123;</span><br><span class="line">   NSLog(@<span class="string">"blk1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, myConcurrentDispatchQueue, ^&#123;</span><br><span class="line">   NSLog(@<span class="string">"blk2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, myConcurrentDispatchQueue, ^&#123;</span><br><span class="line">   NSLog(@<span class="string">"done."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_notify</code>函数的第一个参数是要监听的group，第二个参数可以是任意queue，第三个参数是在上面提交的block都执行完后要执行的block，它会被追加到第二个参数指定的queue中。</p>
<p>也可以使用<code>dispatch_group_wait</code>函数等待前面提交到group中的block都执行完。这是个同步执行的函数，第二个参数指定要等待的group，第二个参数指定等待的超时时间，类型也是<code>dispatch_time_t</code>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait(<span class="name">group</span>, DISPATCH_TIME_FOREVER)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>指定为<code>DISPATCH_TIME_FOREVER</code>，意味着永久等待。</p>
<p>在Swift中对应的实现如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let<span class="built_in"> group </span>= DispatchGroup()</span><br><span class="line">myConcurrentDispatchQueue.async(group: group) &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"blk0"</span>)</span><br><span class="line">&#125;</span><br><span class="line">myConcurrentDispatchQueue.async(group: group) &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"blk1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">myConcurrentDispatchQueue.async(group: group) &#123;</span><br><span class="line">	<span class="builtin-name">print</span>(<span class="string">"blk2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">DispatchQueue.main.async &#123;</span><br><span class="line">	<span class="builtin-name">print</span>(<span class="string">"done."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法用<code>dispatch_group_enter</code>指定提交到group中的任务开始的地方，<code>dispatch_group_leave</code>指定该任务结束的地方。这在不好将任务封装到block中时就派上用场了。两个函数必须成对使用。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(<span class="name">group</span>)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">	// 耗时任务<span class="number">1</span></span><br><span class="line">	dispatch_group_leave(<span class="name">group</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_group_enter(<span class="name">group</span>)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">myConcurrentDispatchQueue</span>, ^&#123;</span><br><span class="line">	// 耗时任务<span class="number">2</span></span><br><span class="line">	dispatch_group_leave(<span class="name">group</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_group_notify(<span class="name">group</span>, myConcurrentDispatchQueue, ^&#123;</span><br><span class="line">   NSLog(@<span class="string">"done."</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>Swift中的对应实现如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">dispatchGroup </span>= <span class="keyword">DispatchGroup()</span></span><br><span class="line"><span class="keyword"> </span>       </span><br><span class="line"><span class="keyword">dispatchGroup.enter()</span></span><br><span class="line"><span class="keyword">longRunningFunction </span>&#123; </span><br><span class="line">	<span class="keyword">dispatchGroup.leave() </span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">dispatchGroup.enter()</span></span><br><span class="line"><span class="keyword">longRunningFunctionTwo </span>&#123; </span><br><span class="line">	<span class="keyword">dispatchGroup.leave() </span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">dispatchGroup.notify(queue: </span>.main) &#123;</span><br><span class="line">	print(<span class="string">"done."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><p>通过前面的总结，我们知道可以通过串行队列和<code>dispatch_barrier_async</code>来确保同一时刻只有一个线程访问资源，我们还可以通过<code>Dispatch Semaphore</code>进行更细粒度的控制。<code>Dispatch Semaphore</code>是GCD提供的持有计数的信号，在计数为0时其他线程只能等待，当计数大于等于1时才可以继续执行。</p>
<p>在ObjectiveC中，通过<code>dispatch_semaphore_signal</code>函数将信号量加1，通过<code>dispatch_semaphore_wait</code>函数将信号量减1，或者在信号量为0再次执行到该函数时就会阻塞来访的线程。这样，在<code>dispatch_semaphore_signal</code>和<code>dispatch_semaphore_wait</code>之间的代码片段就被保护起来了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为0时，一开始执行到dispatch_semaphore_wait时线程就被阻塞了，直到到了你设置的等待时间。</span></span><br><span class="line"><span class="comment">// 设置为1时，在dispatch_semaphore_wait中又指定了DISPATCH_TIME_FOREVER，就可以达到同时只有一个线程访问被保护的代码片段。</span></span><br><span class="line"><span class="comment">// 设置为大于1时，就意味着允许同时有多少个线程对资源进行访问。</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mbArray = [[<span class="built_in">NSMutableArray</span> alloc]init];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       <span class="comment">// 如果当前信号量为0就阻塞来访的线程，直到到了指定的时间。</span></span><br><span class="line">       <span class="comment">// 如果当前信号量不为0则将其减一，但不会阻塞。</span></span><br><span class="line">       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">       </span><br><span class="line">       [mbArray addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>, i);</span><br><span class="line">       sleep(<span class="number">3</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 任务执行结束，信号量加1</span></span><br><span class="line">       dispatch_semaphore_signal(semaphore);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift中的实现，代码变得简洁了许多。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> semaphore = DispatchSemaphore(<span class="keyword">value</span>: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="number">100</span> &#123;</span><br><span class="line">    DispatchQueue.<span class="keyword">global</span>().<span class="keyword">async</span> &#123;</span><br><span class="line">    	<span class="comment">// Swift中可以调用无参数的wait方法，来等待直到获得了信号量。</span></span><br><span class="line">    	semaphore.wait()</span><br><span class="line">       print(<span class="string">"wait: "</span>, i)</span><br><span class="line">       sleep(<span class="number">1</span>)</span><br><span class="line">       semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>Dispatch Source也是GCD中的成员，<strong>它是BSD系内核惯有功能kqueue的包装</strong>。使用Dispatch Source可以处理XNU内核中发生的各种事件，具体如下表所示。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DISPACH_SOURCE_TYPE_READ</code></td>
<td>检测到对文件系统对象的读操作</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_WRITE</code></td>
<td>检测到对文件系统对象的写操作</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_TIMER</code></td>
<td>监听一个定时器</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_VNODE</code></td>
<td>检测到文件系统对象有变动</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_SIGNAL</code></td>
<td>接收信号</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_PROC</code></td>
<td>检测到与进程相关的事件</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_MEMORYPRESSURE</code></td>
<td>检测到与内存压力相关的事件</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_MACH_SEND</code></td>
<td>MACH端口发送</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_MACH_RECV</code></td>
<td>MACH端口接收</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_DATA_ADD</code></td>
<td>变量增加</td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_DATA_OR</code></td>
<td>变量OR</td>
</tr>
</tbody>
</table>
<p>在开发iOS应用时，用到的比较多的可能就是用Dispatch Source来实现一个定时器了，会比<code>NSTimer</code>更加精准。下面来看一下Dispatch Source是怎么使用的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_source_create函数创建一个Dispatch Source</span></span><br><span class="line">dispatch_source_t <span class="keyword">source</span> = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, myDescriptor, <span class="number">0</span>, myQueue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.配置该Dispatch Source</span></span><br><span class="line"><span class="comment">//   - 设置监听到事件时的回调</span></span><br><span class="line"><span class="comment">//   - 如果是定时器类型的Dispatch Source，需要通过 dispatch_source_set_timer函数创建一个定时器，然后将事件处理回调与该定时器关联</span></span><br><span class="line">dispatch_source_set_event_handler(<span class="keyword">source</span>, ^&#123;</span><br><span class="line">   size_t estimated = dispatch_source_get_data(<span class="keyword">source</span>);</span><br><span class="line">   </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.如果会调用dispatch_source_cancel函数取消该Dispatch Source，则再配置一下被取消时的处理回调。</span></span><br><span class="line">dispatch_source_set_cancel_handler(<span class="keyword">source</span>, ^&#123;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.调用dispatch_resume开始处理事件，因为创建完Dispatch Source不会立即就能处理事件，必须要等配置完才可以，所以要手动触发开始处理。</span></span><br><span class="line">dispatch_resume(<span class="keyword">source</span>);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_source_create</code>函数需要4个参数，第1个参数指定要监听的是哪个事件，也就是上面表中列出的这些事件。第2个参数是要监视的底层系统句柄，与第1个参数指定的事件类型有关。比如监听与文件系统相关的事件，该参数就是打开文件获得的文件描述符。在没有时，可以传0。第3个参数也是要看第1个参数指定了什么事件类型，比如指定了<code>DISPACH_SOURCE_TYPE_VNODE</code>，但是文件的变动又具体分很多种情况，比如删除、改名字等等。我在下表中列出了其可能出现的Event Flags，可以用<code>|</code>指定多个类型。如果没有时可以传0。第4个参数指定对事件处理的block要提交到的队列。</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>Event Flags</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DISPACH_SOURCE_TYPE_VNODE</code></td>
<td><code>DISPATCH_VNODE_LINK</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_VNODE_WRITE</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_VNODE_ATTRIB</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_VNODE_DELETE</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_VNODE_EXTEND</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_VNODE_RENAME</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_VNODE_REVOKE</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_VNODE_FUNLOCK</code></td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_PROC</code></td>
<td><code>DISPATCH_PROC_EXIT</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_PROC_FORK</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_PROC_SIGNAL</code></td>
</tr>
<tr>
<td></td>
<td><code>DISPATCH_PROC_EXEC</code></td>
</tr>
<tr>
<td><code>DISPACH_SOURCE_TYPE_MACH_SEND</code></td>
<td><code>DISPATCH_MACH_SEND_DEAD</code></td>
</tr>
</tbody>
</table>
<p><code>dispatch_source_get_data</code>函数的返回值会根据创建Dispatch Source时指定的事件类型，确定其含义。比如你创建的是<code>DISPACH_SOURCE_TYPE_READ</code>类型的Dispatch Source，返回值就是预计可读取的字节数。再比如你创建的是<code>DISPACH_SOURCE_TYPE_VNODE</code>类型的Dispatch Source，返回值就是收到的具体是哪种变动的flag值。</p>
<p>关于Dispatch Source在各种事件类型时如何使用，可以看苹果官方文档中给出的例子：<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW22" target="_blank" rel="noopener">Dispatch Source Examples</a>。</p>
<p>Swift中Dispatch Source的使用变得更简单了一些，与Dispatch Queue一样，Swift将其以类的方式进行封装。因为没有了宏定义，<a href="https://developer.apple.com/documentation/dispatch/dispatchsource" target="_blank" rel="noopener">DispatchSource</a>类为每一种事件类型提供了对应的类方法来创建DispatchSource实例。DispatchSource遵循<code>DispatchSourceProtocol</code>，该协议里面定义了<code>setCancelHandler</code>、<code>cancel</code>、<code>resume</code>等等方法。</p>
<h2 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h2><p>当你要读取较大文件时，为了提高读取效率，一定记住了GCD中有一个利器可以帮助你，那就是<a href="https://developer.apple.com/documentation/dispatch/dispatch_i_o?language=objc" target="_blank" rel="noopener">Dispatch I/O</a> 和 <a href="https://developer.apple.com/documentation/dispatch/dispatch_data?language=objc" target="_blank" rel="noopener">Dispatch Data</a>的搭配使用。通过Dispatch I/O读写文件时，使用Global Dispatch Queue将一个文件按照某个大小read/write。也就是可以做到有多个线程同时操作文件，自然效率会提高。读取到的每一块数据也无需放到一个块更大的内存中进行合并，<code>dispatch_data_t</code>的一个相当独特的属性是它可以基于零碎的内存区域。Dispatch Data提供了<code>dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2);</code>函数，可以将两块数据组合起来，但是不会开辟新的内存空间来存放两块数据，只是retain了data1和data2。GCD还提供了提供了其他如<code>dispatch_data_create_map</code>和<code>dispatch_data_create_subrange</code>等等对<code>dispatch_data_t</code>的操作，具体的可以在官方文档中查到。</p>
<p>再说一下<code>dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void (^cleanup_handler)(int error));</code>函数，它会返回一个只有文件描述符的创建好的通道。第一个参数type可以取值<code>DISPATCH_IO_STREAM</code>或<code>DISPATCH_IO_RANDOM</code>，也就是你可以创建一个流通道或一个随机存取通道。如果你打开了硬盘上的一个文件，你可以使用它来创建一个随机存取的通道（因为这样的文件描述符是可寻址的）。如果你打开了一个套接字，你可以创建一个流通道。</p>
<p>接下来就是从创建好的Dispatch I/O通道读取数据了，通过<code>void dispatch_io_read(dispatch_io_t channel, off_t offset, size_t length, dispatch_queue_t queue, dispatch_io_handler_t io_handler);</code>函数读取，也有与之对应的写函数。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dispatch_io_read</span>(_channel, <span class="number">0</span>, SIZE_MAX, _myQueue, ^(<span class="keyword">bool </span>done, dispatch_data_t <span class="meta">data</span>, int error)&#123;</span><br><span class="line">    <span class="meta">if</span> (<span class="meta">data</span> != NULL) &#123;</span><br><span class="line">        <span class="meta">if</span> (_<span class="meta">data</span> == NULL) &#123;</span><br><span class="line">            _<span class="meta">data</span> = <span class="meta">data</span><span class="comment">;</span></span><br><span class="line">        &#125; <span class="meta">else</span> &#123;</span><br><span class="line">            _<span class="meta">data</span> = dispatch_data_create_concat(_<span class="meta">data</span>, <span class="meta">data</span>)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self </span>processData]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果你只是想读取一个文件，在读取的过程中不需要做其他处理，GCD提供了一个便捷的函数<code>dispatch_read</code>，你只需要传文件描述符，以及在所有数据都读取完成后要执行的block。也有对应的写函数<code>dispatch_write</code>，你只需提供待写入的<code>dispatch_data_t</code>，和所有数据写入完成后要执行的block。当然这两个也是异步read/write的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>【1】</strong> 苹果官方文档<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html#//apple_ref/doc/uid/TP40008091-CH100-SW1" target="_blank" rel="noopener">Concurrency and Application Design</a></p>
<p><strong>【2】</strong> ObjC中国里的这篇<a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">并行编程：API 及挑战</a></p>
<p><strong>【3】</strong> ObjC中国里的这篇<a href="https://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并行 API</a></p>
<p><strong>【4】</strong> <a href="https://www.raywenderlich.com/5370-grand-central-dispatch-tutorial-for-swift-4-part-1-2" target="_blank" rel="noopener">Grand Central Dispatch Tutorial for Swift 4: Part 1/2</a></p>
<p><strong>【5】</strong> <a href="http://www.hangge.com/blog/cache/detail_745.html" target="_blank" rel="noopener">Swift - 多线程实现方式（3） - Grand Central Dispatch（GCD）</a></p>
<p><strong>【3】</strong> 《Objective-C 高级编程》</p>
<p><strong>【4】</strong> 《Effective Objective-C 2.0》(英文版)</p>
<div class="note info"><p><strong>本文作者：</strong>意林<br><strong>本文链接：</strong><a href="http://www.shinancao.cn/2019/06/15/iOS-GCD-API" target="_blank" rel="noopener">http://www.shinancao.cn/2019/06/15/iOS-GCD-API</a><br><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank" rel="noopener">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</p>
</div>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
            <a href="/tags/GCD/" rel="tag"># GCD</a>
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/08/iOS-block-1/" rel="next" title="轻松理解Block  ">
                <i class="fa fa-chevron-left"></i> 轻松理解Block  
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/18/iOS-NSOperation/" rel="prev" title="开始使用Operation Queue吧  ">
                开始使用Operation Queue吧   <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="gitment_container"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="意林">
          <p class="site-author-name" itemprop="name">意林</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">67</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">89</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/shinancao" target="_blank" rel="external nofollow" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/3178558825/profile?topnav=1&wvr=6&is_all=1" target="_blank" rel="external nofollow" title="微博">
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/150971507/" target="_blank" rel="external nofollow" title="豆瓣">
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Queue"><span class="nav-number">1.</span> <span class="nav-text">Dispatch Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建自定义队列"><span class="nav-number">1.1.</span> <span class="nav-text">创建自定义队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主队列和全局队列"><span class="nav-number">1.2.</span> <span class="nav-text">主队列和全局队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标队列"><span class="nav-number">1.3.</span> <span class="nav-text">目标队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务调度"><span class="nav-number">2.</span> <span class="nav-text">任务调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加任务到队列"><span class="nav-number">2.1.</span> <span class="nav-text">添加任务到队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟执行"><span class="nav-number">2.2.</span> <span class="nav-text">延迟执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只执行一次"><span class="nav-number">2.3.</span> <span class="nav-text">只执行一次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻碍执行"><span class="nav-number">2.4.</span> <span class="nav-text">阻碍执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代执行"><span class="nav-number">2.5.</span> <span class="nav-text">迭代执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#挂起-恢复队列"><span class="nav-number">2.6.</span> <span class="nav-text">挂起/恢复队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Group"><span class="nav-number">3.</span> <span class="nav-text">Dispatch Group</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Semaphore"><span class="nav-number">4.</span> <span class="nav-text">Dispatch Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Source"><span class="nav-number">5.</span> <span class="nav-text">Dispatch Source</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-I-O"><span class="nav-number">6.</span> <span class="nav-text">Dispatch I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">意林</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" rel="external nofollow">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






	
		
		
		
		<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
		<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
		<script>
			var gitment = new Gitment({
			  //id: '页面 ID',
			  owner: 'shinancao',
			  repo: 'shinancao.github.io',
			  oauth: {
				client_id: 'd9ac25dfb2084f02efb1',
				client_secret: '7b127bf1c8bccb72ea55c1220c0db3d3e505672e'
			  }
			});
			gitment.render('gitment_container');
		</script>
	


  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
